# Эксплуатация BoF. Классическое переполнение буфера без обхода защитных механизмов DEP/ASLR.
Веб-интерфейс у сервера отсутствует, начнем со сканирования Nmap и увидим доступные нам порты
![2025-08-27 16 24 12](https://github.com/user-attachments/assets/66fa8963-943b-45b4-90a7-7c9187c239e2)
Перебираем порты и успешно подключаемся только к 3301 порту, с ним и будем работать.Все вводимые данные на сервере фильтруются, прописываем HELP и видим доступные нам команды которые проходят
<img width="832" height="619" alt="Снимок экрана 2025-08-27 в 16 30 00" src="https://github.com/user-attachments/assets/badaa2a0-0185-4fc4-9398-5a676287221c" />

Так как у нас фильтруются все строки кроме разрешенных, буду передавать в буфер строку + нагрузку. Напишу небольшую программу на пайтоне, где создам лист и буду передавать элементы каждого разрешенного значения в цикле, чтобы понять при каком элементе происходит переполнение буфера. Так же создам паттерн на 2500 байт используя msf pattern для создания проверочного буфера в коде, сам код выглядит вот так
<img width="830" height="255" alt="Снимок экрана 2025-08-27 в 16 35 57" src="https://github.com/user-attachments/assets/cd5526da-3953-4242-883a-0904ab54f746" />

Сервер падает на значении “GTER ”, буду проверять offset используя msf-pattern со значением нашего EIP и вижу, что буфер дает всего 147 байт, из опыта знаю, что шелл нагрузка созданная через msfvenom занимает 350-385 байт, чего не хватит для использования шелл кода

<img width="825" height="522" alt="Снимок экрана 2025-08-27 в 16 37 25" src="https://github.com/user-attachments/assets/b2c1fc6b-37c7-44dd-98ab-19c085589b4f" />

<img width="830" height="143" alt="Снимок экрана 2025-08-27 в 16 37 56" src="https://github.com/user-attachments/assets/1df58165-18e5-4909-9608-9d012d1c79e5" />

Продолжаю искать значения с допустимым размером буфера и останавливаюсь на строке «BRUN » и так же проверяю offset, где вижу значение в 2007 байт, чего хватит на размещение шелл кода
<img width="616" height="82" alt="Снимок экрана 2025-08-27 в 16 39 03" src="https://github.com/user-attachments/assets/fbfaa323-ea5e-47a9-908c-68df6678aa1d" />

Начну написание нашего фаззера, нужно убедиться, что значение 2007 действительно корректное и имеется контроль EIP, подам значение “\x42\x42\x42\x42” и должен увидеть его в регистре EIP
<img width="646" height="293" alt="Снимок экрана 2025-08-27 в 16 40 37" src="https://github.com/user-attachments/assets/7aa1b9fb-217e-4736-830f-1bda207617fe" />

Фиксирую, что контролирую значение EIP так как туда попала проверочная строка с 4 символами “B”. Важно отметить значение регистра ESP, так как именно в него и буду передавать полезную нагрузку созданную через msfvenom

<img width="292" height="279" alt="Снимок экрана 2025-08-27 в 16 42 18" src="https://github.com/user-attachments/assets/0449fe03-3f2c-488c-a573-d8a6085a304e" />

Так как убедилися в контроле EIP, и поскольку ESP указывает на данные после EIP(где будет лежать наш шелл код), воспользуюсь инструкцией JMP ESP Которая перенаправит выполнение на стек, где лежит шеллкод. Найду подходящий модуль с инструкцией.

<img width="833" height="239" alt="Снимок экрана 2025-08-27 в 16 48 46" src="https://github.com/user-attachments/assets/532df8c5-5dbb-415b-b4c2-e40d7d8adc7f" />

По условию задачи защита ASLR у нас отключена, поэтому остановлюсь на поиске инструкции в lib.dll
<img width="836" height="121" alt="Снимок экрана 2025-08-27 в 16 49 43" src="https://github.com/user-attachments/assets/cb30ad83-23b9-4032-9dab-806d83ef3b32" />

Воспользуюсь регистром первой инструкции, для убеждения значения регистра и его соответствию инстрункции JMP ESP
<img width="706" height="169" alt="Снимок экрана 2025-08-27 в 16 51 36" src="https://github.com/user-attachments/assets/f3a177c0-6c56-4bb9-ab23-ded74560346b" />

Добавлю в фаззер значение JMP ESP в формате little-endian. Теперь проверю наш сервер на обработку плохих символов, сформирую набор байтов от \x00
до \xff и буду отслеживать их обработку в дампе используя код
<img width="830" height="760" alt="Снимок экрана 2025-08-27 в 16 52 59" src="https://github.com/user-attachments/assets/3e9b9e05-d740-4848-a9dc-f59b1bec4acf" />

В самом дампе вижу искажение начиная с \x00, буду убирать так каждый символ, чтобы они не ломали шелл код
<img width="717" height="345" alt="Снимок экрана 2025-08-27 в 16 53 52" src="https://github.com/user-attachments/assets/e9603657-7d4b-4b74-8361-8be22caf8e64" />

Мне повезло, так как  на данном сервере был только один плохой символ, убрав который дамп заполнился всеми до FF
<img width="355" height="405" alt="Снимок экрана 2025-08-27 в 16 54 43" src="https://github.com/user-attachments/assets/a0a6f786-ceba-4ff9-9a4f-ad2978eb90ce" />

Осталось сформировать саму полезную нагрузку используя msfvenom, не забывая добавить параметр для исключения плохого символа
<img width="827" height="70" alt="Снимок экрана 2025-08-27 в 16 55 31" src="https://github.com/user-attachments/assets/613dc8b7-c81d-4469-bfb5-c57221c6773b" />

Вот так будет выглядеть основная строка фаззера для передачи на сервер, где eip – инструкция JMP ESP, а buffer – шеллкод
<img width="715" height="184" alt="Снимок экрана 2025-08-27 в 16 56 26" src="https://github.com/user-attachments/assets/b3cd9d57-f382-4818-a30c-57e4a5804650" />

Пробую запуск эксплойта и вижу, что пролетаю значения регистров и не попадаю в шелл код
<img width="832" height="502" alt="Снимок экрана 2025-08-27 в 16 58 51" src="https://github.com/user-attachments/assets/364ab528-63f4-472d-912f-a26f4e624d18" />

Добавлю к строке буфера значения nop инструкций, которые ничего не делают и передают управление следующей команде, добавил \x90 * 8 в виде переменной nops, и итоговая строка выглядит так
<img width="658" height="172" alt="Снимок экрана 2025-08-27 в 17 00 11" src="https://github.com/user-attachments/assets/8f3f36a5-2114-406e-96d8-1b64f236cb3e" />

Поднимаю слушателя nc, успешно получаю оболочку, а затем забираю флаг
<img width="831" height="493" alt="Снимок экрана 2025-08-27 в 17 01 05" src="https://github.com/user-attachments/assets/a4d0a048-197f-4aa0-b7bc-cda8749ddcb0" />

